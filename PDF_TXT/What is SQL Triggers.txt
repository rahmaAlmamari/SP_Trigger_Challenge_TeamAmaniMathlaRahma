What is SQL Triggers?
A trigger is a stored procedure in a database that automatically invokes whenever a special event in the database occurs. By using SQL triggers, developers can automate tasks, ensure data consistency, and keep accurate records of database activities. For example, a trigger can be invoked when a row is inserted into a specified table or when specific table columns are updated.

---------------------
Types of SQL triggers
There are several main types of SQL triggers. These trigger types are grouped according to the specific events they respond to and the operations they perform.

1. DML Triggers (Data Manipulation Language): DML triggers fire when we manipulate data with commands like INSERT, UPDATE, or DELETE. These triggers are perfect for scenarios where we need to validate data before it is inserted, log changes to a table, or cascade updates across related tables.

Example: Prevent Unauthorized Updates 
CREATE TRIGGER prevent_update 
ON students
FOR UPDATE 
AS 
BEGIN 
   PRINT 'You can not insert, update and delete this table i'; 
   ROLLBACK; 
END;
------
2. DDL Triggers (Data Definition Language): The Data Definition Language (DDL) command events such as Create_table, Create_view, drop_table, Drop_view, and Alter_table cause the DDL triggers to be activated. They allow us to track changes in the structure of the database. The trigger will prevent any table creation, alteration, or deletion in the database.

Example: Prevent Table Deletions

CREATE TRIGGER prevent_table_creation
ON DATABASE
FOR CREATE_TABLE, ALTER_TABLE, DROP_TABLE
AS 
BEGIN
   PRINT 'you can not create, drop and alter table in this database';
   ROLLBACK;
END;

--
--> another explanation
How DDL Trigger Works?
Every DDL operation generates one Transaction in case of the DDL Trigger have been applied at the Database or the Server level. The SQL Server generates the events with relevant information in the same transaction following the operation. Prepare a metric with extracting the DDL event function(EVENTDATA()) to wraps a policy or standards for deployment:

DDL Trigger Flow

The EVENTDATA() is an inbuilt function of the DDL trigger in SQL Server and that would return exchange occasion subtleties with the number of the fields in XML format

EventType (Create View, Alter View, Drop View, etc…)
PostTime (Event trigger time)
SPID (SQL Server session ID)
ServerName (SQL Server instance name)
LoginName (SQL Server Login name)
UserName (username for login, by default dbo schema as username)
DatabaseName (name of database where trigger was executed)
SchemaName (schema name of the View)
ObjectName (Name of the View)
ObjectType (Object types. such as Table, view, procedure, etc…)
TSQLCommand (Schema deployment Query which is executed by user)
SetOptions (SET Option which are applied while Creating View or Modify it)
CommandText (Create, Alter or Drop object command)
EVENTDATA() returns multiple fields in XML format as shown above and using those fields, we are able to create such metrics to track various events of DDL over the objects. In general, each DDL event of the object schema changes can be appended into the table, these event types are mentioned in the header body of ä trigger with the FOR CREATE_, ALTER_, DROP_,…


------

3. Logon Triggers: Logon triggers are useful for monitoring user sessions or restricting user access to the database. As a result, the PRINT statement messages and any errors generated by the trigger will all be visible in the SQL Server error log.

Example: Track User Logins

CREATE TRIGGER track_logon
ON LOGON
AS
BEGIN
   PRINT 'A new user has logged in.';
END;
--> another explanation
Logon triggers in SQL Server
Triggers is a database code that gets executed in case of a precisely defined event. We can use logon triggers to control the SQL login security. SQL Server automatically executes the logon triggers once a logon event occurs. It gets executed before a user session is established and authentication is successful.

We use two terms for a database successful connection in any database.

Authentication: We specify a username and password to connect using SQL authentication. It is a validation of the user’s credentials
Authorization: It is a permission that allows you to do specific tasks. You may be authorized to have full access to a specific database but not authorized to make any changes at the instance level
Logon Trigger integration

If any user is unable to authenticate to SQL Server (wrong credentials), SQL Server does not execute the logon triggers. SQL Server starts an implicit transaction before the logon triggers fires. It is independent of any user transaction. In the case of the logon trigger, the transaction count is 1. In case SQL returns an exception, its value sets to zero. It fails the implicit transaction, and the user session is not established. User connection also fails in case of the error having severity more significant than 20 inside the trigger.
--------------------------

Advantages of Triggers
Data Integrity: Triggers help enforce consistency and business rules, ensuring that data follows the correct format.
Automation: Triggers eliminate the need for manual intervention by automatically performing tasks such as updating, inserting, or deleting records when certain conditions are met.
Audit Trail: Triggers can track changes in a database, providing an audit trail of INSERT, UPDATE, and DELETE operations.
Performance: By automating repetitive tasks, triggers improve SQL query performance and reduce manual workload.

---------------------
Advantages of SQL Triggers
1) It helps in maintaining the integrity constraints in the database tables, especially when the primary key and foreign key constrain are not defined.

2) It sometimes also helps in keeping the SQL codes short and simple as I show in the real-life example.

3) It helps in maintaining the track of all the changes (update, deletion and insertion) occurs in the tables through inserting the changes values in the audits tables.

4) Sometimes if the code is not well managed, then it can help in maintaining the database constraints defined on the tables on which the trigger is defined. For example, suppose if have a situation that there is an online learning system in which a user can register in the multiple course.

Disadvantages of Triggers

1) Hard to maintain since this may be a possibility that the new developer doesn’t able to know about the trigger defined in the database and wonder how data is inserted, deleted or updated automatically.

2) They are hard to debug since they are difficult to view as compared to stored procedures, views, functions, etc.

----------------------
Real-World Use Cases of SQL Triggers
1. Automatically Updating Related Tables (DML Trigger Example)

case :
Triggers can automatically perform tasks, like updating related tables when data changes. Imagine we have a database for students, where the student_grades table holds individual subject grades. If the grade of a student is updated, we may also need to update the total_scores table
code :
CREATE TRIGGER update_student_score
AFTER UPDATE ON student_grades
FOR EACH ROW
BEGIN
   UPDATE total_scores
   SET score = score + :new.grade
   WHERE student_id = :new.student_id;
END;

This ensures that every time a student's grade is updated, the total score in the total_scores table is automatically recalculated.

2. Data Validation (Before Insert Trigger Example)

case :
Triggers can be used to validate data before it is inserted into a table, ensuring that the data follows specific business rules. For instance, we may want to ensure that the grades being inserted are within a valid range (say 0 to 100).

code :CREATE TRIGGER validate_grade
BEFORE INSERT ON student_grades
FOR EACH ROW
BEGIN
   IF :new.grade < 0 OR :new.grade > 100 THEN
      RAISE_APPLICATION_ERROR(-20001, 'Invalid grade value.');
   END IF;
END;

The trigger checks if the inserted grade is valid. If not, it throws an error and prevents the insertion.

--------------------
BEFORE and AFTER Triggers
SQL triggers can be specified to run BEFORE or AFTER the triggering event.

- BEFORE Triggers: These run before the action (INSERT, UPDATE, DELETE) is executed. They’re great for data validation or modifying values before they are committed to the database.

- AFTER Triggers: Execute after the SQL statement completes. Useful for logging or cascading updates to other tables.
----
In what scenarios will you use instead of trigger and after trigger?


You will use "INSTEAD trigger" to take alternative actions before the update happens.

Some of the uses of instead of trigger's are:-

Reject updates which are not valid.
Take some alternative action if any error occurs.
To implement cascading deletes. For instance you want to delete a customer record. But in order to delete the customer record you also have to delete address records. So you can create a instead of trigger which will first delete the address table before executing delete on customer table.

 While "AFTER trigger" is useful when you want to execute trigger logic after the data has been updated.

Some uses of after triggers are:-

For recording Audit trail where you want new and old values to be inserted in to audit table.
Updating values after the update has happened. For instance in a sales table if number of products and per product is inserted, you can create an after trigger which will calculate the total sales amount using these two values.





----------------
Syntax

create trigger [trigger_name] 
[before | after]  
{insert | update | delete}  
on [table_name]  
FOR EACH ROW
BEGIN
END;

-----------------

Viewing and Managing Triggers in SQL

SELECT name, is_instead_of_trigger
FROM sys.triggers
WHERE type = 'TR';


Key Terms

name: The name of the trigger.
is_instead_of_trigger: Whether the trigger is an INSTEAD OF trigger.
type = 'TR': This filters the results to show only triggers.
----
